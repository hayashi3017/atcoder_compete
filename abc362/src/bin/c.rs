use proconio::input;

fn main() {
    input! {
        n: usize,
        lr: [(isize, isize);n]
    }

    /*
       xの候補を一つずつ全探索することは計算量的にできない

       N=1の場合、x=[0]のみ。つまり、l <= 0 <= rならばYes
       N=2の場合、x=[0, 0] or x=[1, -1] [-1, 1] [2, -2]...など
       N=3の場合、x=[0, 0, 0] or x=[2, -1, -1] [1, -1, 0]...など

       ⇒　0を含むかどうかは重要かもしれない
       ただしそのロジックを当てはめられないケースはある

       和が0になることの言い換えは可能か？

       最後は下記条件を満たす必要がある
           n-1までの和が0で、最後の数字が0
           n-1までの和がkで、最後の数字が-k

    */
}

// https://atcoder.jp/contests/abc362/editorial/10394

// 貪欲に値を決めることができるパターンであるため、細かいパターンを考える必要がない様子。つまり数字マジックに気づけるかどうかが肝だった可能性あり。
